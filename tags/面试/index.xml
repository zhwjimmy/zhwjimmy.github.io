<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on 松溪夜谈</title><link>https://zhwjimmy.github.io/tags/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on 松溪夜谈</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 10 Jan 2023 12:25:15 +0800</lastBuildDate><atom:link href="https://zhwjimmy.github.io/tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>103. 二叉树的锯齿形层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 12:25:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid><description>我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。我们可以使用一个标志位来判断当前遍历的是奇数层还是偶数层，如果是奇数层，则将当前节点的值插入到结果切片的末尾；如果是偶数层，则将当前节点的值插入到结果切片的头部。</description></item><item><title>107. 二叉树的层序遍历 II</title><link>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</link><pubDate>Tue, 10 Jan 2023 11:54:24 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。我们可以使用一个二维切片来存储遍历的结果，然后将结果逆序输出即可得到自底向上的层次遍历。</description></item><item><title>102. 二叉树的层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 11:43:31 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。</description></item><item><title>145. 二叉树的后序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:09 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</guid><description>后序遍历的顺序是左-右-根，所以先遍历左子树，再遍历右子树，最后访问根节点。</description></item><item><title>144. 二叉树的前序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:03 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</guid><description>遍历二叉树指的是在二叉树的每个节点上都执行某个操作。二叉树遍历有三种常用的方法：前序遍历、中序遍历和后序遍历。</description></item><item><title>94. 二叉树的中序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</link><pubDate>Tue, 10 Jan 2023 10:47:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</guid><description>中序遍历的顺序是左-根-右，所以先遍历左子树，再访问根节点，最后遍历右子树。</description></item><item><title>99. 恢复二叉搜索树</title><link>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</link><pubDate>Mon, 09 Jan 2023 16:25:43 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</guid><description>解法一 这道题的目标是在给定的二叉搜索树中的两个节点被交换了位置之后，恢复原来的树。</description></item><item><title>106. 从中序与后序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:11:20 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的中序遍历序列为 inorder 和后序遍历序列为 postorder。</description></item><item><title>105. 从前序与中序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:06:40 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的前序遍历序列为 preorder 和中序遍历序列为 inorder。</description></item><item><title>124. 二叉树中的最大路径和</title><link>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</link><pubDate>Mon, 09 Jan 2023 12:48:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</guid><description>二叉树中的最大路径和问题指的是，给定一棵二叉树，求出其中一条从根节点出发，到叶子节点结束的路径，使得该路径上节点的权值之和最大。</description></item><item><title>Leetcode题型分类总结</title><link>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</link><pubDate>Mon, 09 Jan 2023 12:00:00 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</guid><description>二叉树 144.</description></item></channel></rss>