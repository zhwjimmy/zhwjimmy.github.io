<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on 松溪夜谈</title><link>https://zhwjimmy.github.io/tags/leetcode/</link><description>Recent content in leetcode on 松溪夜谈</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 12 Jan 2023 16:06:13 +0800</lastBuildDate><atom:link href="https://zhwjimmy.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>257. 二叉树的所有路径</title><link>https://zhwjimmy.github.io/post/leetcode/257-binary-tree-paths/</link><pubDate>Thu, 12 Jan 2023 16:06:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/257-binary-tree-paths/</guid><description>给定一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</description></item><item><title>404. 左叶子之和</title><link>https://zhwjimmy.github.io/post/leetcode/404-sum-of-left-leaves/</link><pubDate>Thu, 12 Jan 2023 15:03:11 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/404-sum-of-left-leaves/</guid><description>可以使用递归的方式遍历二叉树，并在遍历过程中累加左叶子节点的值。</description></item><item><title>129. 求根节点到叶节点数字之和</title><link>https://zhwjimmy.github.io/post/leetcode/129-sum-root-to-leaf-numbers/</link><pubDate>Thu, 12 Jan 2023 13:35:02 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/129-sum-root-to-leaf-numbers/</guid><description>给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。计算从根节点到叶节点生成的 所有数字之和 。</description></item><item><title>437. 路径总和 III</title><link>https://zhwjimmy.github.io/post/leetcode/437-path-sum-iii/</link><pubDate>Thu, 12 Jan 2023 12:16:37 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/437-path-sum-iii/</guid><description>代码实现如下：</description></item><item><title>104. 二叉树的最大深度</title><link>https://zhwjimmy.github.io/post/leetcode/104-maximum-depth-of-binary-tree/</link><pubDate>Wed, 11 Jan 2023 23:15:27 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/104-maximum-depth-of-binary-tree/</guid><description>代码实现如下：</description></item><item><title>113. 路径总和 II</title><link>https://zhwjimmy.github.io/post/leetcode/113-path-sum-ii/</link><pubDate>Wed, 11 Jan 2023 22:57:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/113-path-sum-ii/</guid><description>代码实现如下：</description></item><item><title>112. 路径总和</title><link>https://zhwjimmy.github.io/post/leetcode/112-path-sum/</link><pubDate>Wed, 11 Jan 2023 22:55:16 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/112-path-sum/</guid><description>代码实现如下：</description></item><item><title>111. 二叉树的最小深度</title><link>https://zhwjimmy.github.io/post/leetcode/111-minimum-depth-of-binary-tree/</link><pubDate>Tue, 10 Jan 2023 14:57:14 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/111-minimum-depth-of-binary-tree/</guid><description>求一棵树的最小深度时，递归访问每个节点并求出它的最小深度是一种常用的方法。</description></item><item><title>110. 平衡二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/110-balanced-binary-tree/</link><pubDate>Tue, 10 Jan 2023 14:55:50 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/110-balanced-binary-tree/</guid><description>给定一个二叉树，判断它是否是高度平衡的二叉树。一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</description></item><item><title>101. 对称二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/101-symmetric-tree/</link><pubDate>Tue, 10 Jan 2023 12:57:45 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/101-symmetric-tree/</guid><description>可以使用递归的方法来判断一棵树是否为镜像对称的。首先判断两棵树是否为空，如果其中一棵树为空，则返回 false；如果两棵树都为空，则返回 true。然后判断两棵树的根节点的值是否相等，如果不相等，则返回 false。最后分别递归判断两棵树的左子树的左子树和右子树的右子树是否相同，以及左子树的右子树和右子树的左子树是否相同。</description></item><item><title>100. 相同的树</title><link>https://zhwjimmy.github.io/post/leetcode/100-same-tree/</link><pubDate>Tue, 10 Jan 2023 12:52:51 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/100-same-tree/</guid><description>可以使用递归的方法来判断两棵树是否相同。首先判断两棵树是否为空，如果其中一棵树为空，则返回 false；如果两棵树都为空，则返回 true。然后判断两棵树的根节点的值是否相等，如果不相等，则返回 false。最后分别递归判断两棵树的左子树和右子树是否相同。</description></item><item><title>103. 二叉树的锯齿形层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 12:25:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid><description>可以使用队列来帮助实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。可以使用一个标志位来判断当前遍历的是奇数层还是偶数层，如果是奇数层，则将当前节点的值插入到结果切片的末尾；如果是偶数层，则将当前节点的值插入到结果切片的头部。</description></item><item><title>107. 二叉树的层序遍历 II</title><link>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</link><pubDate>Tue, 10 Jan 2023 11:54:24 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。我们可以使用一个二维切片来存储遍历的结果，然后将结果逆序输出即可得到自底向上的层次遍历。</description></item><item><title>102. 二叉树的层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 11:43:31 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。</description></item><item><title>145. 二叉树的后序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:09 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</guid><description>后序遍历的顺序是左-右-根，所以先遍历左子树，再遍历右子树，最后访问根节点。</description></item><item><title>144. 二叉树的前序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:03 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</guid><description>遍历二叉树指的是在二叉树的每个节点上都执行某个操作。二叉树遍历有三种常用的方法：前序遍历、中序遍历和后序遍历。</description></item><item><title>94. 二叉树的中序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</link><pubDate>Tue, 10 Jan 2023 10:47:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</guid><description>中序遍历的顺序是左-根-右，所以先遍历左子树，再访问根节点，最后遍历右子树。</description></item><item><title>99. 恢复二叉搜索树</title><link>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</link><pubDate>Mon, 09 Jan 2023 16:25:43 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</guid><description>解法一 这道题的目标是在给定的二叉搜索树中的两个节点被交换了位置之后，恢复原来的树。</description></item><item><title>106. 从中序与后序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:11:20 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的中序遍历序列为 inorder 和后序遍历序列为 postorder。</description></item><item><title>105. 从前序与中序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:06:40 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的前序遍历序列为 preorder 和中序遍历序列为 inorder。</description></item><item><title>124. 二叉树中的最大路径和</title><link>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</link><pubDate>Mon, 09 Jan 2023 12:48:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</guid><description>二叉树中的最大路径和问题指的是，给定一棵二叉树，求出其中一条从根节点出发，到叶子节点结束的路径，使得该路径上节点的权值之和最大。</description></item><item><title>Leetcode题型分类总结</title><link>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</link><pubDate>Mon, 09 Jan 2023 12:00:00 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</guid><description>二叉树 144.</description></item></channel></rss>