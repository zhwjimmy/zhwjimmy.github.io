<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TECH on 松溪夜谈</title><link>https://zhwjimmy.github.io/categories/tech/</link><description>Recent content in TECH on 松溪夜谈</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 13 Jan 2023 12:19:46 +0800</lastBuildDate><atom:link href="https://zhwjimmy.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>92. 反转链表 II</title><link>https://zhwjimmy.github.io/post/leetcode/92-reverse-linked-list-ii/</link><pubDate>Fri, 13 Jan 2023 12:19:46 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/92-reverse-linked-list-ii/</guid><description/></item><item><title>206. 反转链表</title><link>https://zhwjimmy.github.io/post/leetcode/206-reverse-linked-list/</link><pubDate>Fri, 13 Jan 2023 11:58:41 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/206-reverse-linked-list/</guid><description>反转链表算法题可以使用迭代或递归来实现。</description></item><item><title>142. 环形链表 II</title><link>https://zhwjimmy.github.io/post/leetcode/142-linked-list-cycle-ii/</link><pubDate>Fri, 13 Jan 2023 11:23:54 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/142-linked-list-cycle-ii/</guid><description>这一题相当于脑筋急转弯，或者需要通过数学简单推导。</description></item><item><title>141. 环形链表</title><link>https://zhwjimmy.github.io/post/leetcode/141-linked-list-cycle/</link><pubDate>Fri, 13 Jan 2023 10:54:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/141-linked-list-cycle/</guid><description>环形链表算法题可以使用快慢指针来解决。</description></item><item><title>239. 滑动窗口最大值</title><link>https://zhwjimmy.github.io/post/leetcode/239-sliding-window-maximum/</link><pubDate>Thu, 12 Jan 2023 18:16:40 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/239-sliding-window-maximum/</guid><description>针对滑动窗口最大值，使用单调队列结构可以巧妙的解决。</description></item><item><title>503. 下一个更大元素 II</title><link>https://zhwjimmy.github.io/post/leetcode/503-next-greater-element-ii/</link><pubDate>Thu, 12 Jan 2023 17:31:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/503-next-greater-element-ii/</guid><description>单调栈+取模变成双倍数组</description></item><item><title>496. 下一个更大元素</title><link>https://zhwjimmy.github.io/post/leetcode/496-next-greater-element-i/</link><pubDate>Thu, 12 Jan 2023 16:34:39 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/496-next-greater-element-i/</guid><description>单调栈是解决这类题目的有效工具。</description></item><item><title>226. 翻转二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/226-invert-binary-tree/</link><pubDate>Thu, 12 Jan 2023 16:21:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/226-invert-binary-tree/</guid><description>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</description></item><item><title>257. 二叉树的所有路径</title><link>https://zhwjimmy.github.io/post/leetcode/257-binary-tree-paths/</link><pubDate>Thu, 12 Jan 2023 16:06:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/257-binary-tree-paths/</guid><description>给定一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</description></item><item><title>404. 左叶子之和</title><link>https://zhwjimmy.github.io/post/leetcode/404-sum-of-left-leaves/</link><pubDate>Thu, 12 Jan 2023 15:03:11 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/404-sum-of-left-leaves/</guid><description>可以使用递归的方式遍历二叉树，并在遍历过程中累加左叶子节点的值。</description></item><item><title>129. 求根节点到叶节点数字之和</title><link>https://zhwjimmy.github.io/post/leetcode/129-sum-root-to-leaf-numbers/</link><pubDate>Thu, 12 Jan 2023 13:35:02 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/129-sum-root-to-leaf-numbers/</guid><description>给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。计算从根节点到叶节点生成的 所有数字之和 。</description></item><item><title>437. 路径总和 III</title><link>https://zhwjimmy.github.io/post/leetcode/437-path-sum-iii/</link><pubDate>Thu, 12 Jan 2023 12:16:37 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/437-path-sum-iii/</guid><description>代码实现如下：</description></item><item><title>104. 二叉树的最大深度</title><link>https://zhwjimmy.github.io/post/leetcode/104-maximum-depth-of-binary-tree/</link><pubDate>Wed, 11 Jan 2023 23:15:27 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/104-maximum-depth-of-binary-tree/</guid><description>代码实现如下：</description></item><item><title>113. 路径总和 II</title><link>https://zhwjimmy.github.io/post/leetcode/113-path-sum-ii/</link><pubDate>Wed, 11 Jan 2023 22:57:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/113-path-sum-ii/</guid><description>代码实现如下：</description></item><item><title>112. 路径总和</title><link>https://zhwjimmy.github.io/post/leetcode/112-path-sum/</link><pubDate>Wed, 11 Jan 2023 22:55:16 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/112-path-sum/</guid><description>代码实现如下：</description></item><item><title>Golang 底层数据结构</title><link>https://zhwjimmy.github.io/post/programming/go/go-data-structure/</link><pubDate>Wed, 11 Jan 2023 16:27:48 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-data-structure/</guid><description>Slice 扩容 在Go语言中，当向一个slice添加元素时，如果当前slice的容量已经不足以容纳新添加的元素，那么Go语言的运行时会自动为该slice分配新的底层数组，并将原有的数据复制到新的数组中，并将新的元素添加到新的数组中。这个过程被称为&amp;quot;扩容&amp;quot;。</description></item><item><title>Golang 垃圾回收机制</title><link>https://zhwjimmy.github.io/post/programming/go/go-garbage-collection/</link><pubDate>Wed, 11 Jan 2023 15:47:08 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-garbage-collection/</guid><description>1.3版本的标记-清除法 流程 STW暂停业务逻辑 找到可达对象，进行标记 清除不可达对象 停止STW，继续运行业务 缺点 STW，程序会出现卡顿 标记需要扫描整个heap 清除数据会产生heap碎片 1.</description></item><item><title>MySQL文章系列（五） 事务</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-transaction/</link><pubDate>Wed, 11 Jan 2023 15:26:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-transaction/</guid><description>事务并发操作的问题 脏读是指一个事务读取到了其他事务未提交的数据。</description></item><item><title>MySQL文章系列（四） 锁</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-lock/</link><pubDate>Wed, 11 Jan 2023 14:19:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-lock/</guid><description>锁的分类 按粒度分类 全局锁 表级锁 行锁 行锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。</description></item><item><title>MySQL文章系列（三） 索引</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-index/</link><pubDate>Wed, 11 Jan 2023 12:46:30 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-index/</guid><description>索引分类 按数据结构分类 B+tree索引 基于B+tree索引的索引类型有主键索引、唯一索引、普通索引 Hash索引 全文索引 按物理存储分类 聚簇索引 二级索引 索引常见概念 回表 覆盖索引 最左前缀原则 索引下推 普通索引 vs 唯一索引 普通索引和唯一索引是不同类型的索引，有着不同的特性和用途。</description></item><item><title>MySQL文章系列（二） 更新过程</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-update-process/</link><pubDate>Tue, 10 Jan 2023 15:35:27 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-update-process/</guid><description>MySQL更新过程 前置过程参考MySQL查询过程</description></item><item><title>MySQL文章系列（一） 查询过程</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-query-process/</link><pubDate>Tue, 10 Jan 2023 15:35:17 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-query-process/</guid><description>MySQL逻辑架构 网络连接层 与MySQL服务器建立连接 服务层（MySQL Server） 连接池 查询缓存 以key-value对的形式缓存在内存中，命中缓存则直接返回 MySQL8.</description></item><item><title>111. 二叉树的最小深度</title><link>https://zhwjimmy.github.io/post/leetcode/111-minimum-depth-of-binary-tree/</link><pubDate>Tue, 10 Jan 2023 14:57:14 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/111-minimum-depth-of-binary-tree/</guid><description>求一棵树的最小深度时，递归访问每个节点并求出它的最小深度是一种常用的方法。</description></item><item><title>110. 平衡二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/110-balanced-binary-tree/</link><pubDate>Tue, 10 Jan 2023 14:55:50 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/110-balanced-binary-tree/</guid><description>给定一个二叉树，判断它是否是高度平衡的二叉树。一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</description></item><item><title>101. 对称二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/101-symmetric-tree/</link><pubDate>Tue, 10 Jan 2023 12:57:45 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/101-symmetric-tree/</guid><description>可以使用递归的方法来判断一棵树是否为镜像对称的。首先判断两棵树是否为空，如果其中一棵树为空，则返回 false；如果两棵树都为空，则返回 true。然后判断两棵树的根节点的值是否相等，如果不相等，则返回 false。最后分别递归判断两棵树的左子树的左子树和右子树的右子树是否相同，以及左子树的右子树和右子树的左子树是否相同。</description></item><item><title>100. 相同的树</title><link>https://zhwjimmy.github.io/post/leetcode/100-same-tree/</link><pubDate>Tue, 10 Jan 2023 12:52:51 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/100-same-tree/</guid><description>可以使用递归的方法来判断两棵树是否相同。首先判断两棵树是否为空，如果其中一棵树为空，则返回 false；如果两棵树都为空，则返回 true。然后判断两棵树的根节点的值是否相等，如果不相等，则返回 false。最后分别递归判断两棵树的左子树和右子树是否相同。</description></item><item><title>103. 二叉树的锯齿形层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 12:25:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid><description>可以使用队列来帮助实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。可以使用一个标志位来判断当前遍历的是奇数层还是偶数层，如果是奇数层，则将当前节点的值插入到结果切片的末尾；如果是偶数层，则将当前节点的值插入到结果切片的头部。</description></item><item><title>107. 二叉树的层序遍历 II</title><link>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</link><pubDate>Tue, 10 Jan 2023 11:54:24 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。我们可以使用一个二维切片来存储遍历的结果，然后将结果逆序输出即可得到自底向上的层次遍历。</description></item><item><title>102. 二叉树的层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 11:43:31 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。</description></item><item><title>145. 二叉树的后序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:09 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</guid><description>后序遍历的顺序是左-右-根，所以先遍历左子树，再遍历右子树，最后访问根节点。</description></item><item><title>144. 二叉树的前序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:03 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</guid><description>遍历二叉树指的是在二叉树的每个节点上都执行某个操作。二叉树遍历有三种常用的方法：前序遍历、中序遍历和后序遍历。</description></item><item><title>94. 二叉树的中序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</link><pubDate>Tue, 10 Jan 2023 10:47:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</guid><description>中序遍历的顺序是左-根-右，所以先遍历左子树，再访问根节点，最后遍历右子树。</description></item><item><title>99. 恢复二叉搜索树</title><link>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</link><pubDate>Mon, 09 Jan 2023 16:25:43 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</guid><description>解法一 这道题的目标是在给定的二叉搜索树中的两个节点被交换了位置之后，恢复原来的树。</description></item><item><title>106. 从中序与后序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:11:20 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的中序遍历序列为 inorder 和后序遍历序列为 postorder。</description></item><item><title>105. 从前序与中序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:06:40 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的前序遍历序列为 preorder 和中序遍历序列为 inorder。</description></item><item><title>124. 二叉树中的最大路径和</title><link>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</link><pubDate>Mon, 09 Jan 2023 12:48:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</guid><description>二叉树中的最大路径和问题指的是，给定一棵二叉树，求出其中一条从根节点出发，到叶子节点结束的路径，使得该路径上节点的权值之和最大。</description></item><item><title>Leetcode题型分类总结</title><link>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</link><pubDate>Mon, 09 Jan 2023 12:00:00 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</guid><description>二叉树 144.</description></item><item><title>如何利用Github Pages和Hugo搭建个人博客</title><link>https://zhwjimmy.github.io/post/hugo/</link><pubDate>Thu, 05 Jan 2023 14:17:38 +0800</pubDate><guid>https://zhwjimmy.github.io/post/hugo/</guid><description>如果希望快速、免费的搭建一个博客网站，那么Github Pages + Hugo是一个很好的方案。Hugo是用Go语言编写的博客工具，用户可以使用Markdown编写博客内容，然后通过Hugo生成静态页面；Github Pages是Github提供的一项静态站点托管服务，利用该服务用户可以直接发布网站，无需额外申请域名和服务器。</description></item></channel></rss>