<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 松溪夜谈</title><link>https://zhwjimmy.github.io/post/</link><description>Recent content in Posts on 松溪夜谈</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 12 Feb 2023 21:38:08 +0800</lastBuildDate><atom:link href="https://zhwjimmy.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Go系列文章之逃逸分析</title><link>https://zhwjimmy.github.io/post/programming/go/go-escape-analysis/</link><pubDate>Sun, 12 Feb 2023 21:38:08 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-escape-analysis/</guid><description>什么是逃逸分析 编译阶段，分析指针动态范围的方法被称之为逃逸分析。当一个对象的指针被多个方法或线程引用时，称这个指针发生了逃逸。逃逸分析决定一个变量是分配在栈上还是堆上。</description></item><item><title>Go系列文章之数据容器</title><link>https://zhwjimmy.github.io/post/programming/go/go-data-container/</link><pubDate>Sun, 12 Feb 2023 20:55:45 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-data-container/</guid><description>切片 type slice struct{ array unsafe.</description></item><item><title>Go系列文章之调度机制</title><link>https://zhwjimmy.github.io/post/programming/go/go-gmp/</link><pubDate>Sun, 12 Feb 2023 16:30:51 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-gmp/</guid><description>Go调度器的由来 进程 进程是资源分配的最小单位。一个进程可以独立运行，并且拥有独立的内存空间 创建进程的开销很大，需要分配独立内存空间。虚拟内存占用几GB。 进程间的数据交互涉及到进程间通信。 线程 线程是程序执行的最小单位。它是进程内部的一个执行流，共享进程的资源，但拥有自己的寄存器和栈 线程相对进程开销小，线程占用几MB 统一进程下的线程共享虚拟内存、全局变量等数据，交换数据比进程方便 上下文切换相对开销更小 并发和并行 协程 内存在操作系统中分为两部分：内核空间和用户空间。内核空间只有内核程序可以访问；用户空间供应用程序访问。 所以线程分成两部分，内核态线程和用户态线程，用户态线程被称为协程，和内核态线程绑定执行 内核调度线程成本比较高，所以分成两部分：内核线程仍然由内核进行调研；用户态线程创建、销毁不需要系统调用，可以自行维护，切换成本小，被称为协程 协程和线程的绑定关系 N:1 一旦协程阻塞，会造成线程阻塞 1:1 M:N GMP模型 操作系统调度器调度内核线程 线程和P绑定 每个P有一个P的本地队列，存储goroutine 全局g队列 Go的启动周期 先解释下M0和G0的概念</description></item><item><title>Go系列文章之通道</title><link>https://zhwjimmy.github.io/post/programming/go/go-channel/</link><pubDate>Sat, 11 Feb 2023 20:18:04 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-channel/</guid><description>goroutine和channel是Go并发的两大基石</description></item><item><title>网络模型</title><link>https://zhwjimmy.github.io/post/network/network-model/</link><pubDate>Mon, 06 Feb 2023 15:52:19 +0800</pubDate><guid>https://zhwjimmy.github.io/post/network/network-model/</guid><description>IO多路复用 一个服务端进程可以同时处理多个套接字描述符。</description></item><item><title>Redis</title><link>https://zhwjimmy.github.io/post/database/redis/redis/</link><pubDate>Mon, 06 Feb 2023 15:37:26 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/redis/redis/</guid><description>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</description></item><item><title>消息队列</title><link>https://zhwjimmy.github.io/post/component/mq/</link><pubDate>Fri, 03 Feb 2023 16:46:01 +0800</pubDate><guid>https://zhwjimmy.github.io/post/component/mq/</guid><description>消息队列 消息队列的作用 应用解耦 削峰填谷 异步处理 消息模型 队列模型 队列：先进先出 弊端：一个消息只能被其中一个消费者消费 发布-订阅模型 包含模块 发布者 订阅者（通过消费者组实现） 主题/Topic queue队列（rocketmq）/分区partition（kafka） 消费位置 消费者组 队列的作用 为了保证消息的有序性，在一条消息被成功消费之前，下一条消息不能被消费。也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费。为了解决这个问题，提升消费性能，引入队列的概念。 每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。 只在队列上保证消息的有序性，主题层面不保证 消费者组 解决同一个消息多个业务消费的问题 每个消费组都消费主题中一份完整的消息，不同消费组间消费进度不受影响 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。 消费位置 由于消息需要被不同的消费组进行多次消费，所以消费完的消息并不会立即删除，所以消息队列为每个消费组在每个队列上维护了一个消费位置。 消息队列常见场景 如何实现消息有序 如何保证消息不丢失 如何保证消息只消费一次（幂等） 消息积压如何处理 分布式事务 kafka kafka是什么 Kafka 起初是由 Linkedin 公司采用 Scala 语言开发的一个多分区、多副本且基于ZooKeeper协调的分布式消息系统，现己被捐献给 Apache 基金会。目前 Kafka 已经定位为一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。</description></item><item><title>Redis</title><link>https://zhwjimmy.github.io/post/database/redis/redis-v2/</link><pubDate>Mon, 16 Jan 2023 16:52:55 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/redis/redis-v2/</guid><description>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</description></item><item><title>92. 反转链表 II</title><link>https://zhwjimmy.github.io/post/leetcode/92-reverse-linked-list-ii/</link><pubDate>Fri, 13 Jan 2023 12:19:46 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/92-reverse-linked-list-ii/</guid><description/></item><item><title>206. 反转链表</title><link>https://zhwjimmy.github.io/post/leetcode/206-reverse-linked-list/</link><pubDate>Fri, 13 Jan 2023 11:58:41 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/206-reverse-linked-list/</guid><description>反转链表算法题可以使用迭代或递归来实现。</description></item><item><title>142. 环形链表 II</title><link>https://zhwjimmy.github.io/post/leetcode/142-linked-list-cycle-ii/</link><pubDate>Fri, 13 Jan 2023 11:23:54 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/142-linked-list-cycle-ii/</guid><description>这一题相当于脑筋急转弯，或者需要通过数学简单推导。</description></item><item><title>141. 环形链表</title><link>https://zhwjimmy.github.io/post/leetcode/141-linked-list-cycle/</link><pubDate>Fri, 13 Jan 2023 10:54:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/141-linked-list-cycle/</guid><description>环形链表算法题可以使用快慢指针来解决。</description></item><item><title>239. 滑动窗口最大值</title><link>https://zhwjimmy.github.io/post/leetcode/239-sliding-window-maximum/</link><pubDate>Thu, 12 Jan 2023 18:16:40 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/239-sliding-window-maximum/</guid><description>针对滑动窗口最大值，使用单调队列结构可以巧妙的解决。</description></item><item><title>503. 下一个更大元素 II</title><link>https://zhwjimmy.github.io/post/leetcode/503-next-greater-element-ii/</link><pubDate>Thu, 12 Jan 2023 17:31:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/503-next-greater-element-ii/</guid><description>单调栈+取模变成双倍数组</description></item><item><title>496. 下一个更大元素</title><link>https://zhwjimmy.github.io/post/leetcode/496-next-greater-element-i/</link><pubDate>Thu, 12 Jan 2023 16:34:39 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/496-next-greater-element-i/</guid><description>单调栈是解决这类题目的有效工具。</description></item><item><title>226. 翻转二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/226-invert-binary-tree/</link><pubDate>Thu, 12 Jan 2023 16:21:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/226-invert-binary-tree/</guid><description>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</description></item><item><title>257. 二叉树的所有路径</title><link>https://zhwjimmy.github.io/post/leetcode/257-binary-tree-paths/</link><pubDate>Thu, 12 Jan 2023 16:06:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/257-binary-tree-paths/</guid><description>给定一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</description></item><item><title>404. 左叶子之和</title><link>https://zhwjimmy.github.io/post/leetcode/404-sum-of-left-leaves/</link><pubDate>Thu, 12 Jan 2023 15:03:11 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/404-sum-of-left-leaves/</guid><description>可以使用递归的方式遍历二叉树，并在遍历过程中累加左叶子节点的值。</description></item><item><title>129. 求根节点到叶节点数字之和</title><link>https://zhwjimmy.github.io/post/leetcode/129-sum-root-to-leaf-numbers/</link><pubDate>Thu, 12 Jan 2023 13:35:02 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/129-sum-root-to-leaf-numbers/</guid><description>给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。计算从根节点到叶节点生成的 所有数字之和 。</description></item><item><title>437. 路径总和 III</title><link>https://zhwjimmy.github.io/post/leetcode/437-path-sum-iii/</link><pubDate>Thu, 12 Jan 2023 12:16:37 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/437-path-sum-iii/</guid><description>代码实现如下：</description></item><item><title>104. 二叉树的最大深度</title><link>https://zhwjimmy.github.io/post/leetcode/104-maximum-depth-of-binary-tree/</link><pubDate>Wed, 11 Jan 2023 23:15:27 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/104-maximum-depth-of-binary-tree/</guid><description>代码实现如下：</description></item><item><title>113. 路径总和 II</title><link>https://zhwjimmy.github.io/post/leetcode/113-path-sum-ii/</link><pubDate>Wed, 11 Jan 2023 22:57:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/113-path-sum-ii/</guid><description>代码实现如下：</description></item><item><title>112. 路径总和</title><link>https://zhwjimmy.github.io/post/leetcode/112-path-sum/</link><pubDate>Wed, 11 Jan 2023 22:55:16 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/112-path-sum/</guid><description>代码实现如下：</description></item><item><title>Golang 底层数据结构</title><link>https://zhwjimmy.github.io/post/programming/go/go-data-structure/</link><pubDate>Wed, 11 Jan 2023 16:27:48 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-data-structure/</guid><description>Slice 扩容 在Go语言中，当向一个slice添加元素时，如果当前slice的容量已经不足以容纳新添加的元素，那么Go语言的运行时会自动为该slice分配新的底层数组，并将原有的数据复制到新的数组中，并将新的元素添加到新的数组中。这个过程被称为&amp;quot;扩容&amp;quot;。</description></item><item><title>Golang 垃圾回收机制</title><link>https://zhwjimmy.github.io/post/programming/go/go-garbage-collection/</link><pubDate>Wed, 11 Jan 2023 15:47:08 +0800</pubDate><guid>https://zhwjimmy.github.io/post/programming/go/go-garbage-collection/</guid><description>1.3版本的标记-清除法 流程 STW暂停业务逻辑 找到可达对象，进行标记 清除不可达对象 停止STW，继续运行业务 缺点 STW，程序会出现卡顿 标记需要扫描整个heap 清除数据会产生heap碎片 1.</description></item><item><title>MySQL文章系列（六） 事务</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-transaction/</link><pubDate>Wed, 11 Jan 2023 15:26:13 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-transaction/</guid><description>事务并发操作的问题 脏读。指一个事务读取到了其他事务未提交的数据。 不可重复读。指事务A查询到数据后，事务B做了修改后提交，此时事务A在此查询数据时发现和前一次数据不一致。 幻读。指事务A查询到数据后，事务B新插入数据，此时事务A再次查询时发现数据变多。 事务的隔离级别 数据库系统中的事务隔离级别是用来保证事务并发操作之间的隔离性的。隔离级别的高低决定了事务之间的可见性和可能的并发冲突。</description></item><item><title>MySQL文章系列（五） 锁</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-lock/</link><pubDate>Wed, 11 Jan 2023 14:19:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-lock/</guid><description>锁的分类 按粒度分类 全局锁 表级锁 行锁 行锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。</description></item><item><title>MySQL文章系列（四） 索引</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-index/</link><pubDate>Wed, 11 Jan 2023 12:46:30 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-index/</guid><description>索引的分类 按存储结构 B+树索引 哈希索引 全文索引 B+树索引 多路平衡查找树，非叶子节点只存储索引，叶子节点存储数据</description></item><item><title>MySQL文章系列（三） 更新过程</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-update-process/</link><pubDate>Tue, 10 Jan 2023 15:35:27 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-update-process/</guid><description>MySQL更新过程 前置过程参考MySQL查询过程</description></item><item><title>MySQL文章系列（二） 查询过程</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-query-process/</link><pubDate>Tue, 10 Jan 2023 15:35:17 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-query-process/</guid><description>MySQL查询过程 首先，客户端和MySQL服务器建立连接。连接器负责和客户端建立连接、获取权限和管理连接。</description></item><item><title>111. 二叉树的最小深度</title><link>https://zhwjimmy.github.io/post/leetcode/111-minimum-depth-of-binary-tree/</link><pubDate>Tue, 10 Jan 2023 14:57:14 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/111-minimum-depth-of-binary-tree/</guid><description>求一棵树的最小深度时，递归访问每个节点并求出它的最小深度是一种常用的方法。</description></item><item><title>110. 平衡二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/110-balanced-binary-tree/</link><pubDate>Tue, 10 Jan 2023 14:55:50 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/110-balanced-binary-tree/</guid><description>给定一个二叉树，判断它是否是高度平衡的二叉树。一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</description></item><item><title>101. 对称二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/101-symmetric-tree/</link><pubDate>Tue, 10 Jan 2023 12:57:45 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/101-symmetric-tree/</guid><description>可以使用递归的方法来判断一棵树是否为镜像对称的。首先判断两棵树是否为空，如果其中一棵树为空，则返回 false；如果两棵树都为空，则返回 true。然后判断两棵树的根节点的值是否相等，如果不相等，则返回 false。最后分别递归判断两棵树的左子树的左子树和右子树的右子树是否相同，以及左子树的右子树和右子树的左子树是否相同。</description></item><item><title>100. 相同的树</title><link>https://zhwjimmy.github.io/post/leetcode/100-same-tree/</link><pubDate>Tue, 10 Jan 2023 12:52:51 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/100-same-tree/</guid><description>可以使用递归的方法来判断两棵树是否相同。首先判断两棵树是否为空，如果其中一棵树为空，则返回 false；如果两棵树都为空，则返回 true。然后判断两棵树的根节点的值是否相等，如果不相等，则返回 false。最后分别递归判断两棵树的左子树和右子树是否相同。</description></item><item><title>103. 二叉树的锯齿形层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 12:25:15 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid><description>可以使用队列来帮助实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。可以使用一个标志位来判断当前遍历的是奇数层还是偶数层，如果是奇数层，则将当前节点的值插入到结果切片的末尾；如果是偶数层，则将当前节点的值插入到结果切片的头部。</description></item><item><title>MySQL文章系列（一） 基础知识</title><link>https://zhwjimmy.github.io/post/database/mysql/mysql-base/</link><pubDate>Tue, 10 Jan 2023 12:23:22 +0800</pubDate><guid>https://zhwjimmy.github.io/post/database/mysql/mysql-base/</guid><description>MySQL逻辑架构 网络连接层 与MySQL服务器建立连接 服务层（MySQL Server） 连接池 查询缓存 以key-value对的形式缓存在内存中，命中缓存则直接返回 MySQL8.</description></item><item><title>107. 二叉树的层序遍历 II</title><link>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</link><pubDate>Tue, 10 Jan 2023 11:54:24 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/107-binary-tree-level-order-traversal-ii/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。我们可以使用一个二维切片来存储遍历的结果，然后将结果逆序输出即可得到自底向上的层次遍历。</description></item><item><title>102. 二叉树的层序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</link><pubDate>Tue, 10 Jan 2023 11:43:31 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/102-binary-tree-level-order-traversal/</guid><description>层次遍历是按照层来遍历的，所以我们可以使用队列来帮助我们实现层次遍历。首先将根节点入队，然后不断从队列中取出节点并将节点的左右子节点入队，直到队列为空。</description></item><item><title>145. 二叉树的后序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:09 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/145-binary-tree-postorder-traversal/</guid><description>后序遍历的顺序是左-右-根，所以先遍历左子树，再遍历右子树，最后访问根节点。</description></item><item><title>144. 二叉树的前序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</link><pubDate>Tue, 10 Jan 2023 11:32:03 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/144-binary-tree-preorder-traversal/</guid><description>遍历二叉树指的是在二叉树的每个节点上都执行某个操作。二叉树遍历有三种常用的方法：前序遍历、中序遍历和后序遍历。</description></item><item><title>94. 二叉树的中序遍历</title><link>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</link><pubDate>Tue, 10 Jan 2023 10:47:36 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/94-binary-tree-inorder-traversal/</guid><description>中序遍历的顺序是左-根-右，所以先遍历左子树，再访问根节点，最后遍历右子树。</description></item><item><title>99. 恢复二叉搜索树</title><link>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</link><pubDate>Mon, 09 Jan 2023 16:25:43 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/99-recover-binary-search-tree/</guid><description>解法一 这道题的目标是在给定的二叉搜索树中的两个节点被交换了位置之后，恢复原来的树。</description></item><item><title>106. 从中序与后序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:11:20 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的中序遍历序列为 inorder 和后序遍历序列为 postorder。</description></item><item><title>105. 从前序与中序遍历序列构造二叉树</title><link>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link><pubDate>Mon, 09 Jan 2023 16:06:40 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid><description>可以使用递归的方法来构造二叉树。假设给定的前序遍历序列为 preorder 和中序遍历序列为 inorder。</description></item><item><title>124. 二叉树中的最大路径和</title><link>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</link><pubDate>Mon, 09 Jan 2023 12:48:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/124-binary-tree-maximum-path-sum/</guid><description>二叉树中的最大路径和问题指的是，给定一棵二叉树，求出其中一条从根节点出发，到叶子节点结束的路径，使得该路径上节点的权值之和最大。</description></item><item><title>Leetcode题型分类总结</title><link>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</link><pubDate>Mon, 09 Jan 2023 12:00:00 +0800</pubDate><guid>https://zhwjimmy.github.io/post/leetcode/leetcode-summary/</guid><description>二叉树 144.</description></item><item><title>如何利用Github Pages和Hugo搭建个人博客</title><link>https://zhwjimmy.github.io/post/hugo/</link><pubDate>Thu, 05 Jan 2023 14:17:38 +0800</pubDate><guid>https://zhwjimmy.github.io/post/hugo/</guid><description>如果希望快速、免费的搭建一个博客网站，那么Github Pages + Hugo是一个很好的方案。Hugo是用Go语言编写的博客工具，用户可以使用Markdown编写博客内容，然后通过Hugo生成静态页面；Github Pages是Github提供的一项静态站点托管服务，利用该服务用户可以直接发布网站，无需额外申请域名和服务器。</description></item><item><title>《长恨歌》</title><link>https://zhwjimmy.github.io/post/chinese-preview/</link><pubDate>Thu, 05 Jan 2023 12:24:21 +0800</pubDate><guid>https://zhwjimmy.github.io/post/chinese-preview/</guid><description>《长恨歌》是中国唐朝诗人白居易的一首长篇叙事诗。</description></item></channel></rss>